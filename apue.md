#进程控制
##进程标识符

	0 #系统进程，内核的一部分，swapper交换进程
	1 #INIT进程，内核调用，自举内核后启动一个Unix系统，读与系统有关的文件，永远不会终止，一个普通的用户进程，以超级用户权限运行，是所有孤儿进程的父进程。
	2 #页守护进程，负责支持虚拟存储系统的分页操作

	#include<unistd.h>
	pid_t getpid(void); #r:调用进程的进程ID
	pid_t getppid(void); #r:调用进程的父进程ID

##fork()

	pid_t fork()  #两个返回值，子进程中返回0,父进程中返回子进程ID，出错返回-1
	
*Note:*子进程ID返回给父进程的理由：一个进程的子进程可以有多个，没有一个函数可以返回所有子进程的ID，子进程返回0的理由：子进程总是可以调用getppid来获得父进程的ID

子进程是父进程的副本，获得了父进程的数据空间，堆栈的副本，但是并不是共享这些数据空间，只共享正文段。

很多实现并不执行一个父进程的数据空间推栈的完全复制，代替的是写时复制的技术，这些区域父子进程共享，只读，内核只为试图修改数据的进程那块内存生成一个副本，通常是虚拟存储器的第一页。

fork()之后可以通过信号进行同步

*Note:*strlen计算不包含终止字节的null,sizeof包含终止的字节null的缓冲区长度，strlen调用了一次函数，sizeof则在编译的时候计算缓冲区长度

##文件共享
父进程打开的所有文件描述符都会被复制到子进程中，打开的相同文件描述符共享一个文件表项，父子进程共享同一文件偏移量。

fork之后处理文件描述符：
1. 父进程等待子进程结束，其不需要对描述符号做任何处理
2. 父子进程执行不同的程序段，fork之后父子进程各自关闭其不需要用到的描述符号，这样就不会干扰到对方使用的文件描述符，这个方法在网路服务进程中经常用到

##父子进程之间的区别
1. 返回值
2. 进程ID
3. 具有不同的父进程ID 父进程的父进程ID不变
4. 父进程设置的文件锁不会继承给子进程
5. 子进程未处理的alarm被清除
6. 子进程未处理的信号集设置为空集

##fork的两种用法
1. 父进程希望复制自己，为了让父子进程执行不同的代码段，在网络通信服务中是常见的---父进程等待客户端的请求，请求到达以后自己fork一个子进程，让子进程执行相应的功能代码，父进程继续等待客户端请求
2. 一个进程要执行一个不同的程序，子进程fork返回之后立即调用exec

*Note:*一个进程创建一个新的进程之后，子进程往往要调用一个exec函数来执行新的程序，从main开始。调用它并不进行创建新的进程，所以ID不会改变，用fork可以创建子进程，exec可以执行新的程序。exit和两个wait函数进行处理终止和等待终止，这都是基本的UNIX原语

##vfork
vfork父进程调用之后创建一个新的进程，这个进程调用exec一个新的程序，与fork一样，但是不会全部复制，子进程会立即调用exec执行新的程序，所以并用不到这个地址空间，节省了时间，在调用子进程之前在父进程的地址空间中运行，vfork保证了子进程先运行，之后父进程才可能被调度，如果子进程依赖于父进程的进一步动作，会造成死锁
